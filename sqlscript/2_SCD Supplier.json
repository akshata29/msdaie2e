{
	"name": "2_SCD Supplier",
	"properties": {
		"folder": {
			"name": "WorldWideImporters/Logical Data Warehouse/Part 3"
		},
		"content": {
			"query": "USE LogicalDw\nGO\n\n-- When we look at loading changed data for dimensions that must be tracked over time, we have to be aware that Serverless SQL Pools currently does not support updating data in the Data Lake, \n-- it is an append-only process in that files can be added to the underlying storage but we cannot run SQL to change existing data. \n-- However, we can load new and changed dimension data into new destination folders under the root dimension folder.\n\n-- The SQL code below will create a View which targets selecting changed data for Suppliers.\n--DROP VIEW LDW.vwIncrementalSuppliers\nCREATE VIEW LDW.vwIncrementalSuppliers\nAS\nSELECT fct.*,\nfct.filepath(1) AS FilePathDate\nFROM\n    OPENROWSET\n    (\n        BULK 'ChangedData/*/Purchasing_Suppliers/*.csv',\n        DATA_SOURCE = 'ExternalRawDataLake',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE,\n        FIELDTERMINATOR ='|'\n    ) AS fct\n\n\n-- The SQL code below will now write the new and changed data out to a sub-folder /02 in the current Supplier dimension folder. \n-- This can be amended to use dynamic SQL as seen in the Sales Order process. We first select the maximum surrogate key from the current dimension data \n-- and use this to continue the sequence when writing the changed and new data. Within the CSV file is a date column which indicates when the source data changed, we can use this as our ValidFrom value.\n\nDECLARE @MaxKey TINYINT\nSELECT @MaxKey = MAX(SupplierKey) FROM LDW.vwDimSupplier\nIF OBJECT_ID('STG.DimSupplier') IS NOT NULL\nDROP EXTERNAL TABLE STG.DimSupplier;\nCREATE EXTERNAL TABLE STG.DimSupplier\n    WITH\n    (\n        LOCATION = 'conformed/dimensions/dimsupplier/02',\n        DATA_SOURCE = ExternalCuratedDataLake,\n        FILE_FORMAT = SynapseParquetFormat\n    )\nAS\n    SELECT CAST(ROW_NUMBER() OVER(ORDER BY S.SupplierID) AS TINYINT) + @MaxKey AS SupplierKey,\n        S.SupplierID,\n        S.SupplierName,\n        SC.SupplierCategoryName,\n        CAST(S.ValidFrom AS DATE) AS ValidFromDate\n    FROM LDW.vwIncrementalSuppliers S\n    LEFT JOIN LDW.vwSupplierCategories SC ON SC.SupplierCategoryID = S.SupplierCategoryID\n    WHERE S.FilePathDate = '2021-06-22'\n    ORDER BY S.SupplierID;\n\n-- If we now query the existing View to select data from the Supplier dimension, we get all the existing data, the changed data, and the new data. \n-- However, we are missing vital columns which are required to flag the date range validity of a dimension row.\nSELECT *\nFROM LDW.vwDimSupplier\nWHERE SupplierID IN (5,14)\nORDER BY SupplierID;\n\n\n-- We can use the single ValidFrom date to calculate the ValidTo and also calculate the ActiveMember flag for each dimension row. We use the LEAD function and \n-- partition by the SupplierID (source system business key) to generate contiguous date ranges. Please note that we can also use datetime values and change the DATEADD accordingly.\n-- DROP VIEW LDW.vwDimSupplierSCD\nCREATE VIEW LDW.vwDimSupplierSCD\nAS\nSELECT SupplierKey,\n    SupplierID,\n    SupplierName,\n    SupplierCategoryName,\n    ValidFromDate,\n    ISNULL(DATEADD(DAY,-1,LEAD(ValidFromDate,1) OVER (PARTITION BY SupplierID ORDER BY SupplierKey)),'2099-01-01') AS ValidToDate,\n    CASE ROW_NUMBER() OVER(PARTITION BY SupplierID ORDER BY SupplierKey DESC) WHEN 1 THEN 'Y' ELSE 'N' END AS ActiveMember\nFROM LDW.vwDimSupplier\n\n-- Now when we select from the new Dimension View we are able to see date ranges and which row is the current active member.\nSELECT *\nFROM LDW.vwDimSupplierSCD\nWHERE SupplierID IN (1,5,14)\nORDER BY SupplierID,SupplierKey\n\n-- We can now use the SCD version of the Supplier dimension view LDW.vwDimSupplierSCD and use the Sales Order date to select the correct dimension value at the time the Sales Order was created. \n-- We have added an additional JOIN to the new dimension view using the Sales Order date and the Supplier ValidFrom and ValidTo dates.\n-- Drop PROCEDURE STG.FactSalesLoadSCD\nCREATE PROCEDURE STG.FactSalesLoadSCD @ProcessDate DATE\nWITH ENCRYPTION\nAS\nBEGIN\nDECLARE @location varchar(100)\nIF OBJECT_ID('STG.FactSales') IS NOT NULL\nDROP EXTERNAL TABLE STG.FactSales\nSET @location = CONCAT('conformed/facts/factsales/',FORMAT (@ProcessDate, 'yyyy/MM/dd') )\nDECLARE @CreateExternalTableString NVARCHAR(2000)\nSET @CreateExternalTableString =\n    'CREATE EXTERNAL TABLE STG.FactSales\n        WITH\n        (\n            LOCATION = ''' + @location + ''',\n            DATA_SOURCE = ExternalCuratedDataLake,\n            FILE_FORMAT = SynapseParquetFormat\n        )\n    AS\n    SELECT\n        --Surrogate Keys\n        DC.CustomerKey,\n        CAST(FORMAT(SO.OrderDate,''yyyyMMdd'') AS INT) as OrderDateKey,\n        DSI.StockItemKey,\n        DS.SupplierKey,\n        --Degenerate Dimensions\n        CAST(SO.OrderID AS INT) AS OrderID,\n        CAST(SOL.OrderLineID AS INT) AS OrderLineID,\n        --Measure\n        CAST(SOL.Quantity AS INT) AS SalesOrderQuantity,\n        CAST(SOL.UnitPrice AS DECIMAL(18,2)) AS SalesOrderUnitPrice\n    FROM LDW.vwSalesOrdersLines SOL\n    INNER JOIN LDW.vwSalesOrders SO ON SOL.OrderID = SO.OrderID\n    LEFT JOIN LDW.vwDimCustomer DC ON DC.CustomerID = SO.CustomerID\n    LEFT JOIN LDW.vwDimStockItem DSI ON DSI.StockItemID = SOL.StockItemID\n    LEFT JOIN LDW.vwStockItems SI ON SI.StockItemID = DSI.StockItemID\n    LEFT JOIN LDW.vwDimSupplierSCD  DS ON DS.SupplierID = SI.SupplierID AND SO.OrderDate BETWEEN DS.ValidFromDate AND DS.ValidToDate\n    WHERE CAST(CONVERT(varchar, SOL.FilePathDate, 23) AS CHAR(10)) = ''' + CAST(@ProcessDate AS CHAR(10)) + '''  AND CAST(CONVERT(varchar, SO.FilePathDate, 23) AS CHAR(10)) = ''' + CAST(@ProcessDate AS CHAR(10)) + ''''\n    EXEC sp_executesql @CreateExternalTableString\nEND",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "logicaldw",
				"poolName": "Built-in"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}